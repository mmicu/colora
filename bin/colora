#!/usr/bin/env node

'use strict';

const colorNamer = require('color-namer');
const colorsLib = require('colors');
const fs = require('fs');
const hljs = require('highlight.js');
const htmlparser = require('htmlparser2');
const parserlib = require('parserlib');
const path = require('path');
const program = require('commander');
const pkg = require('../package.json');
const util = require('util');

var EXIT = {
  SUCCESS: 0,
  FAILURE: 1
};

var SUPPORTED_COLORS = [ 
  'black',
  'red',
  'green',
  'yellow',
  'blue',
  'magenta',
  'cyan',
  'white',
  'gray',
  'grey'
];

var ColoraUtils = {
  isString: function(s) {
    return typeof s === 'string' || s instanceof String;
  },
  isArray: function(arr) {
    return Array.isArray(arr);
  },
  isBoolean: function(b) {
    return b === true || b === false;
  }
};

var handleColor = function(key, color) {
  var isBackgroundAttr = function(s) {
    return s === 'background' || s === 'background-color';
  }

  try {
    var colors = colorNamer(color)['basic'];
    
    for (var i = 0; i < colors.length; ++i) {
      var c = colors[i]['name'];
      
      if (isBackgroundAttr(key)) // |key| > 0
        c = 'bg' + c[0].toUpperCase() + c.substring(1, c.length);
      if (c in colorsLib)
        return colorsLib[c];
    }
  } catch (e) { }

  return undefined;
};

var HTML_to_Terminal = {}
  // color
HTML_to_Terminal['color'] = function(color) {
  return handleColor('color', color);
};
  // background ~ background-color
HTML_to_Terminal['background'] = function(color) {
  return handleColor('background', color);
};
HTML_to_Terminal['background-color'] = function(color) {
  return handleColor('background-color', color);
};
  // font-weight
HTML_to_Terminal['font-weight'] = function(font_weight) {
  // normal|bold|bolder|lighter|number|initial|inherit
  return colorsLib[font_weight];
};
  // font-style
HTML_to_Terminal['font-style'] = function(font_style) {
  // normal|italic|oblique|initial|inherit
  return colorsLib[font_style];
};
  // text-decoration
HTML_to_Terminal['text-decoration'] = function(text_decoration) {
  // none|underline|overline|line-through|initial|inherit
  return colorsLib[text_decoration];
};

// +++ Theme class +++
var Theme = function(name, path) {
  if (!ColoraUtils.isString(name) || !ColoraUtils.isString(path))
    throw '"name" and "path" must be two strings';

  this.name = name;
  this.path = path;
  this.selectors = new Map();
  this._currentSelectors = [];
};

Theme.prototype.addSelector = function(selector) {
  if (!ColoraUtils.isString(selector))
    throw '"selector" must be a string';

  if (!this.selectors.has(selector))
    this.selectors.set(selector, new Map());
  if (!this._currentSelectors.includes(selector))
    this._currentSelectors.push(selector);
};


Theme.prototype.addProperty = function(property, value) {
  if (!ColoraUtils.isString(property) || !ColoraUtils.isString(value))
    throw '"property" and "value" must be two strings';
  if (!ColoraUtils.isArray(this._currentSelectors))
    throw 'Invalid selectors';
    
  for (var i = 0, l = this._currentSelectors.length; i < l; ++i) {
    var selectorName = this._currentSelectors[i];
    
    if (!this.selectors.has(selectorName))
      throw util.format('First time encountered selector "%s"', selectorName);
    
    var selector = this.selectors.get(selectorName);
    selector.set(property, value); // overwrite duplicates
  }
};

Theme.prototype.getPropertyBySelector = function(property, selector) {
  if (!ColoraUtils.isString(property) || !ColoraUtils.isString(selector))
    throw '"property" and "selector" must be two strings';

  var selectorMap = this.selectors.has(selector)
    ? this.selectors.get(selector)
    : null;

  return selectorMap.has(property)
    ? selectorMap.get(property)
    : null;
};

Theme.prototype.getPropertiesBySelector = function(selector) {
  if (!ColoraUtils.isString(selector))
    throw '"selector" must be a string';

  return this.selectors.has(selector)
    ? this.selectors.get(selector)
    : null;
};

Theme.prototype.parseCSS = function(callback) {
  var cssParser = new parserlib.css.Parser({
    starHack: true,
    underscoreHack: true
  });
  const self = this;
    // listeners:
  cssParser.addListener('startrule', function(event) {
    event.selectors.forEach(function(selector) {
      selector.parts.forEach(function(part) {
        if (part instanceof parserlib.css.SelectorPart && part.elementName === null) {
          part.modifiers.forEach(function(modifier) {
            self.addSelector(modifier.toString());
          });
        }
      });
    });
  });
  
  cssParser.addListener('endrule', function(event) {
    self._currentSelectors = [];
  });


  cssParser.addListener('property', function(event) {
    self.addProperty(event.property.toString(), event.value.toString());
  });
  
  cssParser.addListener('error', function(event) {
    callback({ 
      error: true,
      desc: util.format('parser error: %s (line: %d, col: %d)', 
                        event.message, Number(event.line), Number(event.col))
    });
  });
  
  cssParser.addListener('endstylesheet', function() {
    callback({ error: false, desc: null });
  });

  // caller should handle exception
  cssParser.parse(fs.readFileSync(this.path, 'utf8'));
}

// +++ Functions +++
function getCSSThemePath(themesPath, themeName) {
  if (!ColoraUtils.isString(themesPath) || !ColoraUtils.isString(themeName))
    throw '"themesPath" and "themeName" must be two strings';
  
  if (!fs.existsSync(themesPath))
    throw util.format('Path "%s" does not exist', themesPath);
  
  const ext = '.css';
  var themePath = null;
  var files = fs.readdirSync(themesPath);
  
  for (var i = 0; i < files.length; ++i) {
    var file_ = files[i];
    if (path.extname(file_) === ext && (path.basename(file_) === themeName ||
        path.basename(file_, ext) === themeName))
      return path.join(themesPath, file_);
  }
  
  return null;
}

function applyHTMLTransformation(themeObj, list, selector) {
  if (!ColoraUtils.isString(selector))
    throw '"selector" must be a string';
    
  var properties = themeObj.getPropertiesBySelector(selector);
  if (properties !== null) {
    for (var [key, value] of properties) {
      if (key in HTML_to_Terminal) {
        var func = HTML_to_Terminal[key](value);
        if (func !== undefined)
          list.push(func);
      }
    }
  }
}

function getMaxLineLength(lines) {
  var getTextFromHTMLLine = function(HTMLLine) {
    var ret = '';
    var htmlParser = new htmlparser.Parser({
      ontext: function(text) {
        ret += text;
      }
    }, { decodeEntities: true });
    htmlParser.write(HTMLLine);
    htmlParser.end();
    
    return ret;
  };
  
  if (!ColoraUtils.isArray(lines))
    throw '"lines" must be an array';
  
  var numLines = lines.length;
  if (numLines === 0) return 0;
  
  var textLines = [];
  for (var i = 0; i < numLines; ++i)
    textLines.push(getTextFromHTMLLine(lines[i].trim()));
  
  var max = textLines[0].length;
  for (var i = 0; i < numLines; ++i)
    max = Math.max(textLines[i].length, max);
    
  return max;
}

function applyModifiers(modifiers, text) {
  if (!ColoraUtils.isArray(modifiers))
    throw '"modifiers" must be an array';
  if (!ColoraUtils.isString(text))
    throw '"text" must be a string';
  
  for (var i = modifiers.length - 1, colorApplied = false; i >= 0; --i) {
    var styleName = ('_styles' in modifiers[i] && 
                    ColoraUtils.isArray(modifiers[i]._styles) &&
                    modifiers[i]._styles.length > 0)
                      ? modifiers[i]._styles[0]
                      : null;
    if (styleName !== null && (!colorApplied || !(styleName in SUPPORTED_COLORS)))
      text = modifiers[i](text);
    if (styleName !== null && !colorApplied && styleName in SUPPORTED_COLORS)
      colorApplied = true;
  }
  
  return text;
}

function applyThemeAndPrint(themeObj, data, language) {
  var hljsObj = ColoraUtils.isString(language)
    ? hljs.highlight(language, data)
    : hljs.highlightAuto(data);
  var htmlContent = (hljsObj !== undefined && hljsObj !== null)
    ? hljsObj.value
    : null;
  
  if (htmlContent === null) {
    console.log(data);
  } else {
    console.log(htmlContent)
    var htmlContentToList = htmlContent.split('\n');
    var maxLength = getMaxLineLength(htmlContentToList);
      // list of functions
    var modifiers = [];
      // apply hljs's properties
    applyHTMLTransformation(themeObj, modifiers, '.hljs');
    
    for (var i = 0; i < htmlContentToList.length; ++i) {
      var line = htmlContentToList[i];
      var how_many_pops = 0;
      var totalLen = 0;
      if (line.replace(/\s/g, '').length == 0) continue;
      
      var htmlParser = new htmlparser.Parser({
        onopentag: function(name, attrs) {
          if (name === 'span') {
            var old_len = modifiers.length;
            
            applyHTMLTransformation(themeObj, modifiers, '.' + attrs['class']);
            how_many_pops = modifiers.length - old_len;
            if (how_many_pops < 0) how_many_pops = 0; // just to be sure...
          }
        },
        onclosetag: function(name) {
          if (name === 'span' && modifiers.length > 0 && how_many_pops > 0) {
            if (how_many_pops >= modifiers.length)
              throw 'Too many Array.pop()';
            
            for (var i = 0; i < how_many_pops; ++i) modifiers.pop();
            how_many_pops = 0;
          }
        },
        ontext: function(text) {
          totalLen += text.length;
          process.stdout.write(applyModifiers(modifiers, text));
        }
      }, { decodeEntities: true });
      htmlParser.write(line);
      htmlParser.end();
      var suffix =  + '\n';
      process.stdout.write(
        applyModifiers(modifiers, ' '.repeat(maxLength - totalLen)) +
        '\n'
      );
    }
  }
}

function colora(sourceCode, language, theme, themesPath) {
    // directory that contains all *.css files
  themesPath = path.resolve(themesPath);
  if (!fs.existsSync(themesPath)) {
    console.error(util.format('Path "%s" does not exist', themesPath));
    return EXIT.FAILURE;
  }
    // with the theme name we can obtain its path
  var themePath = getCSSThemePath(themesPath, theme);
  if (themePath === null) {
    console.error(util.format('Cannot find style "%s" in "%s"', theme, themesPath));
    return EXIT.FAILURE;
  }
    // language is not mandatory. highlight.js can detect it
  if (language !== undefined && hljs.getLanguage(language) === undefined) {
    console.error(util.format('highlight.js does not support language "%s"', language));
    return EXIT.FAILURE;
  }
    // parse CSS & print the source code by applying theme
  var themeObj = new Theme(theme, themePath);
  themeObj.parseCSS(function(data) {
    var error_key = 'error';
    var desc_key = 'desc';
    
    if (!(error_key in data) || !(desc_key in data)) {
      console.error('Data returned from "parseCSS" is not valid');
      return EXIT.FAILURE;
    }
    
    var error = data[error_key];
    
    if (error === true) {
      var desc = data[desc_key];
      if (desc === undefined || desc === null) desc = 'unknown error';
      
      console.error(util.format('Unable to parse CSS: %s', desc));
      return EXIT.FAILURE;
    }
    
    try {
      applyThemeAndPrint(themeObj, sourceCode, language);
    } catch (e) {
      console.error(util.format('Unable to apply theme: %s', e));
      return EXIT.FAILURE;
    }
    
    return EXIT.SUCCESS
  });
}

function main(argc, argv) {
  program
    .version(pkg.version)
    .usage('<themes path> [options]')
    .option('-f, --file [file]', 'Source file')
    .option('-l, --language [lang]', 'Programming language')
    .option('-s, --style [style]', 'Style to apply to source code');
  program.parse(process.argv);
  
  var file = program.file || undefined;
  var language = program.language || undefined;
  var style = program.style || 'default';
  var themesPath = program.args[0] || undefined;
  
  if (themesPath === undefined) {
    console.error('Missing argument "themes path". Use -h or --help');
    process.exit(EXIT.FAILURE);
  }
  
  if (file === undefined) {
    process.stdin.resume();
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', function(data) {
      process.exit(colora(data, language, style, themesPath));
    });
  } else {
    if (!fs.existsSync(file)) {
      console.error(util.format('File "%s" does not exist', file));
      process.exit(EXIT.FAILURE);
    }
    
    process.exit(colora(fs.readFileSync(file, 'utf8'), language, style, themesPath));
  }
}

if (typeof require !== 'undefined' && require.main === module)
  main(process.argv.length, process.argv);

// +++ exports +++
exports.MyUtils = ColoraUtils;
exports.Theme = Theme;
