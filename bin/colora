#!/usr/bin/env node

'use strict';

const colorNamer = require('color-namer');
const colorsLib = require('colors');
const fs = require('fs');
const hljs = require('highlight.js');
const htmlparser = require('htmlparser2');
const parserlib = require('parserlib');
const path = require('path');
const util = require('util');

/*
  TODO list:
    * Refactoring.
    * HTML_to_Terminal.
    * Tests.
    * correct 'onclosetag' => it must pop the proper values.
*/

// Theme class
var Theme = function(name, path) {
  if (!isString(name) || !isString(path))
    throw '"name" and "path" must be two strings';

  this.name = name;
  this.path = path;
  this.selectors = new Map();
  this._currentSelector = null;
};

Theme.prototype.addSelector = function(selector) {
  if (!isString(selector))
    throw '"selector" must be a string';

  if (!this.selectors.has(selector)) this.selectors.set(selector, new Map());
    this._currentSelector = selector;
};

Theme.prototype.addProperty = function(property, value) {
  if (!isString(property) || !isString(value))
    throw '"property" and "value" must be two strings';
  if (!isString(this._currentSelector))
    throw 'Invalid selector';
  if (!this.selectors.has(this._currentSelector))
    throw util.format('First time encountered selector "%s"', this._currentSelector);

  var selector = this.selectors.get(this._currentSelector);
  selector.set(property, value); // overwrite duplicates
};

Theme.prototype.getPropertyBySelector = function(property, selector) {
  if (!isString(property) || !isString(selector))
    throw '"property" and "selector" must be two strings';

  var selectorMap = this.selectors.has(selector)
    ? this.selectors.get(selector)
    : null;

  return selectorMap.has(property)
    ? selectorMap.get(property)
    : null;
};

Theme.prototype.getPropertiesBySelector = function(selector) {
  if (!isString(selector))
    throw '"selector" must be a string';

  return this.selectors.has(selector)
    ? this.selectors.get(selector)
    : null;
};

Theme.prototype.parseCSS = function(callback) {
  var cssParser = new parserlib.css.Parser({
    starHack: true,
    underscoreHack: true
  });
  const self = this;
    // listeners:
  cssParser.addListener('startrule', function(event) {
    event.selectors.forEach(function(selector) {
      selector.parts.forEach(function(part) {
        if (part instanceof parserlib.css.SelectorPart) {
          part.modifiers.forEach(function(modifier) {
            self.addSelector(modifier.toString());
          });
        }
      });
    });
  });

  cssParser.addListener('property', function(event) {
    self.addProperty(event.property.toString(), event.value.toString());
  });
  
  cssParser.addListener('error', function(event) {
    throw util.format('parser error: %s (line: %d, col: %d)', 
      event.message, Number(event.line), Number(event.col));
  });
  
  cssParser.addListener('endstylesheet', function() {
    callback();
  });

  // caller should handle exception
  cssParser.parse(fs.readFileSync(this.path, 'utf8'));
}

  //
var EXIT = {
  SUCCESS: 0,
  FAILURE: 1
};

  //
var handleColor = function(key, color) {
  var isBackgroundAttr = function(s) {
    return s === 'background' || s === 'background-color';
  }
  
  try {
    var colors = colorNamer(color)['basic'];
    
    for (var i = 0; i < colors.length; ++i) {
      var c = colors[i]['name'];
      if (isBackgroundAttr(c))
        c = 'bg' + c[0].toUpperCase() + c.substring(1, c.length);
      if (c in colorsLib)
        return colorsLib[c];
    }
  } catch (e) { }
  
  return undefined;
};

  //
var HTML_to_Terminal = {}
  // color
HTML_to_Terminal['color'] = function(color) {
  return handleColor('color', color);
};
  // background ~ background-color
HTML_to_Terminal['background'] = function(color) {
  return handleColor('background', color);
};
HTML_to_Terminal['background-color'] = function(color) {
  return handleColor('background-color', color);
};
  // font-weight
HTML_to_Terminal['font-weight'] = function(font_weight) {
  // only bold
};
  // font-style
HTML_to_Terminal['font-style'] = function(font_style) {
  // only italic
};
  // text-decoration
HTML_to_Terminal['text-decoration'] = function(text_decoration) {
  // only underline
};

// +++ Functions +++
function isString(s) {
  return typeof s === 'string' || s instanceof String;
}

function getCSSThemePath(themesPath, themeName) {
  if (!isString(themesPath) || !isString(themeName))
    throw '"themesPath" and "themeName" must be two strings';
  
  if (!fs.existsSync(themesPath))
    throw util.format('Path "%s" does not exist', themesPath);
  
  const ext = '.css';
  var themePath = null;
  var files = fs.readdirSync(themesPath);
  
  for (var i = 0; i < files.length; ++i) {
    var file_ = files[i];
    if (path.extname(file_) === ext && (path.basename(file_) === themeName ||
        path.basename(file_, ext) === themeName))
      return path.join(themesPath, file_);
  }
  
  return null;
}

function applyHTMLTransformation(themeObj, list, selector) {
  if (!isString(selector))
    throw '"selector" must be a string';
    
  var properties = themeObj.getPropertiesBySelector(selector);
  if (properties !== null) {
    for (var [key, value] of properties) {
      if (key in HTML_to_Terminal) {
        var func = HTML_to_Terminal[key](value);
        if (func !== undefined)
          list.push(func);
      }
    }
  }
}

function applyThemeAndPrint(themeObj, data, language) {
  var hljsObj = isString(language)
    ? hljs.highlight(language, data)
    : hljs.highlightAuto(data);
  var htmlContent = (hljsObj !== undefined && hljsObj !== null)
    ? hljsObj.value
    : null;
  
  if (htmlContent === null) {
    console.log(data);
  } else {
    var htmlContentToList = htmlContent.split('\n');
    var modifiers = []; // list of functions
      // apply hljs's properties
    applyHTMLTransformation(themeObj, modifiers, '.hljs');
    
    for (var i = 0; i < htmlContentToList.length; ++i) {
      var line = htmlContentToList[i];
      if (line.replace(/\s/g, '').length == 0) continue;
      
      var htmlParser = new htmlparser.Parser({
        onopentag: function(name, attrs) {
          if (name === 'span')
            applyHTMLTransformation(themeObj, modifiers, '.' + attrs['class']);
        },
        onclosetag: function(name) {
          if (name === 'span' && modifiers.length > 0)
            modifiers.pop();
        },
        ontext: function(text) {
          for (var i = 0; i < modifiers.length; ++i)
            text = modifiers[i](text);
          process.stdout.write(text);
        }
      }, { decodeEntities: true });
      htmlParser.write(line);
      htmlParser.end();
      process.stdout.write('\n');
    }
  }
}

function main(argc, argv, sourceCode) { 
  if (argc < 4) {
    console.error(util.format('Usage: node %s <themes directory> <theme> [language]', argv[1]));
    process.exit(EXIT.FAILURE);
  }
    // directory that contains all *.css files
  var themesPath = path.resolve(process.argv[2]);
  if (!fs.existsSync(themesPath))if (!fs.existsSync(themesPath)) {
    console.error(util.format('Path "%s" does not exist', themesPath));
    process.exit(EXIT.FAILURE);
  }
    // with the theme name we can obtain its path
  var themeName = process.argv[3];
  var themePath = getCSSThemePath(themesPath, themeName);
  if (themePath === null) {
    console.error(util.format('Cannot find style "%s" in "%s"', themeName, themesPath));
    process.exit(EXIT.FAILURE);
  }
    // language is not mandatory. highlight.js can detect it
  var language = (process.argv.length >= 5)
    ? process.argv[4]
    : null;
  if (language !== null && hljs.getLanguage(language) === undefined) {
    console.error(util.format('highlight.js does not support language "%s"', language));
    process.exit(EXIT.FAILURE);
  }
  
    // parse CSS & print the source code by applying theme
  try {
    var themeObj = new Theme(themeName, themePath);
    themeObj.parseCSS(function() {
      applyThemeAndPrint(themeObj, sourceCode, language);
    });
  } catch (e) {
    console.error(util.format('Error during parsing: %s', e));
    process.exit(1);
  }
}

if (typeof require !== 'undefined' && require.main === module) {
  process.stdin.resume();
  process.stdin.setEncoding('utf8');
  
  process.stdin.on('data', function(data) {
    main(process.argv.length, process.argv, data);
  });
}

// +++ exports +++
exports.isString = isString;
exports.Theme = Theme;
